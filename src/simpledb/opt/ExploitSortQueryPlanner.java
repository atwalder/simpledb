package simpledb.opt;

import simpledb.tx.Transaction;
import simpledb.query.*;
import simpledb.record.RecordFile;
import simpledb.record.TableInfo;
import simpledb.server.SimpleDB;
import simpledb.materialize.MergeJoinPlan;
import simpledb.opt.TablePlanner;
import simpledb.parse.QueryData;
import simpledb.planner.QueryPlanner;
import java.util.*;

/**where is this called (CREATEPLAN())
 *  calls mergejoinplan to call the sortscan
 * A query planner that optimizes using a heuristic-based algorithm.
 * @author Edward Sciore
 */
//project 2: addition, instructions said to
public class ExploitSortQueryPlanner implements QueryPlanner {
   private Collection<TablePlanner> tableplanners = new ArrayList<TablePlanner>();
   private ArrayList<String> fields = new ArrayList<String>();
   private String tblname; //project 2: original table name hopefully
   private TablePlanner getName; //project 2: the selected tableplanner 
   private Transaction tx;
   
   /**
    * Creates an optimized left-deep query plan using the following
    * heuristics.
    * H1. Choose the smallest table (considering selection predicates)
    * to be first in the join order.
    * H2. Add the table to the join order which
    * results in the smallest output.
    */
   public Plan createPlan(QueryData data, Transaction tx) {
	  this.tx = tx;
      this.fields = (ArrayList<String>) data.fields();
      
      // Step 1:  Create a TablePlanner object for each mentioned table
      for (String tblname : data.tables()) {
         TablePlanner tp = new TablePlanner(tblname, data.pred(), tx);
         tableplanners.add(tp);
      }
      
      // Step 2:  Choose the lowest-size plan to begin the join order
      Plan currentplan = getLowestSelectPlan();
      
      // Step 3:  Repeatedly add a plan to the join order
      while (!tableplanners.isEmpty()) {
         Plan p = getLowestJoinPlan(currentplan);
         if (p != null)
            currentplan = p;
         else  // no applicable join
            currentplan = getLowestProductPlan(currentplan);
      }
      this.tblname = getName.getTblname(); //project 2: should be the original file name from the selected tableplanner
      
      // Step 4.  Project on the field names and return
      return new ProjectPlan(currentplan, data.fields());
   }
   
   private Plan getLowestSelectPlan() {
      TablePlanner besttp = null;
      Plan bestplan = null;
      for (TablePlanner tp : tableplanners) {
         Plan plan = tp.makeSelectPlan();
         if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
            besttp = tp;
            bestplan = plan;
         }
      }
      this.getName = besttp; //project 2: added (the most current best tableplanner)
      this.tblname = getName.getTblname(); //project 2: added (tblname assigned based on getLowestSelectPlan)
      tableplanners.remove(besttp); 
      return bestplan;
   }
   
   private Plan getLowestJoinPlan(Plan current) {
      TablePlanner besttp = null;
      Plan bestplan = null;
      for (TablePlanner tp : tableplanners) {
         Plan plan = tp.makeJoinPlan(current);
         if (plan != null && (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput())) {
            besttp = tp;
            this.getName = besttp; //added
            bestplan = plan;
         }
      }
      if (bestplan != null)
         this.getName = besttp; //project 2: added (the most current best tableplanner)
         tableplanners.remove(besttp);    
      return new MergeJoinPlan(getName.getTblname(), bestplan, current, fields.get(0), fields.get(1), tx); //project 2: modify to do the right plan (mergejoinplan)
   }
   
   private Plan getLowestProductPlan(Plan current) {
      TablePlanner besttp = null;
      Plan bestplan = null;
      for (TablePlanner tp : tableplanners) {
         Plan plan = tp.makeProductPlan(current);
         if (bestplan == null || plan.recordsOutput() < bestplan.recordsOutput()) {
            besttp = tp;
            this.getName = besttp; //project 2: added (the most current best tableplanner)
            bestplan = plan;
         }
      }
      this.getName = besttp; //project 2: added (the most current best tableplanner)
      tableplanners.remove(besttp); 
      return bestplan;
   }
}
